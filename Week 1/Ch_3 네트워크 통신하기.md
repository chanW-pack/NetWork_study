# Ch_3 네트워크 통신하기

---

## 3.1 유니캐스트, 멀티캐스트, 브로드캐스트, 애니캐스트

네트워크에서 출발지에서 목적지로 데이터를 전송할 때 사용하는 통신 방식에는 유니캐스트(Unicast), 멀티캐스트(Multicast), 브로드캐스트(Broadcast), 애니캐스트(Anycast)가 있다.

각 통신 방식은 다음과 같다.

- 유니캐스트
    - 1:1 통신
    - 출발지와 목적지가 1:1로 통신
    
- 브로드캐스트
    - 1:모든 통신
    - 동일 네트워크에 존재하는 모든 호스트가 목적지
    
- 멀티캐스트
    - 1:그룹(멀티캐스트 구독 호스트) 통신
    - 하나의 출발지에서 다수의 특정 목적지로 데이터 전송
    
- 애니캐스트
    - 1:1 통신(목적지는 동일 그룹 내의 1개 호스트)
    - 다수의 동일 그룹 중 가장 가까운 호스트에서 응답
    - IPv4에서는 일부 기능 구현, IPv6은 모두 구현 가능
    

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled.png)

> 통신 방식 정리
> 

---

## 3.2 MAC 주소

MAC 주소는 Media Access Control의 줄임말로 2계층(데이터 링크 계층)에서 통신을 위해 네트워크 인터페이스에 할당된 고유 식별자이다. 

MAC 주소는 이더넷과 와이파이를 포함한 대부분의 IEEE 802 네트워크 기술에서 2계층 주소로 사용되며, 네트워크에 접속하는 모든 장비는 MAC 주소라는 물리적인 주소가 있어야 하고 이 주소를 이용하여 서로 통신하게 된다.

### MAC 주소 체계

MAC 주소는 변경할 수 없도록 하드웨어에 고정되어 출하하므로 네트워크 구성 요소마다 다른 주소를 가지고 있다. 제조업체에 하나 이상의 풀을 주고 그 안에서 제조업체가 자체적으로 MAC주소를 할당한다. 이 주소는 국제기구인 IEEE가 관리한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%201.png)

> MAC 추소 체계
> 

- OUI
    - IEEE가 제조사에게 할당하는 부분
    
- UAA
    - 각 제조사에서 네트워크 구성 요소에 할당하는 부분
    

MAC 주소는 이렇게 장비 제조업체 코드와 제조업체가 자체적으로 할당한 값으로 구성된다. 카드나 장비를 생산할 때 하드웨어적으로 정해져 나오므로 MAC주소를 BIA(Burned-in Address)라고도 부름

---

## 3.3 IP 주소

OSI 7계층에서 주소를 갖는 계층은 2,3 계층이다. 2계층은 물리 주소인 MAC 주소를 사용하고, 3계층은 논리 주소인 IP 계층을 사용한다.

IP주소를 포함한 다른 프로토콜 스택의 3계층 주소는 다음과 같은 특징이 있다.

1. 사용자가 변경 가능한 논리 주소이다.
2. 주소에 레벨이 있다. 그룹을 의미하는 네트워크 주소와 호스트 주소로 나뉜다.

### IP주소 체계

우리가 흔히 사용하는 IP주소는 32비트인 IPv4 주소이다. IP는 v4, v6 두 체계가 사용되며 IPv6 주소는 128비트이다. 

IPv4주소를 표기할 때는 4개의 옥텟(Octet)이라고 부르는 8비트 단위로 나누고 각 옥텟은 ‘.’ 으로 구분한다. IP주소는 10진수로 표기하므로 8비트 옥텟은 0~255의 값을 사용할 수 있다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%202.png)

> IPv4 주소 체계
> 

3계층 주소인 IP 주소도 네트워크 주소와 호스트 주소 두 부분으로 나뉜다.

<aside>
💡 2계층 주소인 MAC 주소가 제조업체 코드와 제조업체별 일련 번호 두 부분으로 나뉘는 것과 목적이 다르다.

</aside>

- 네트워크 주소
    - 호스트들을 모은 네트워크를 지칭하는 주소.
    - 네트워크 주소가 동일한 네트워크를 로컬 네트워크라고 한다.
    
- 호스트 주소
    - 하나의 네트워크 내에 존재하는 호스트를 구분하기 위한 주소
    

MAC 주소는 24비트씩 절반으로 나뉘지만 IP 주소의 네트워크 주소와 호스트 주소는 이 둘을 구분하는 **경계점이 고정되어 있지 않다**. 이것이 다른 주소 체계와 IP 주소 체계를 구분하는 가장 큰 특징이다.

IP 주소 체계는 필요한 호스트 개수에 따라 네트워크의 크기를 다르게 설정할 수 있는 클래스(Class) 개념을 도입했다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%203.png)

> 네트워크 주소와 호스트 주소를 나누는 구분자는 클래스(네트워크 크기)에 따라 변경된다.
> 

네트워크 주소와 호스트 주소를 나누는 구분자가 고정되어 있다면 네트워크가 가질 수 있는 호스트 IP숫자가 같기 때문에 모두 같은 크기의 네트워크가 되지만 구분자기 이동할 수 있어 네트워크의 크기가 달라질 수 있다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%204.png)

> 클래스 구분법
> 

---

### 클래스풀과 클래스리스

IP 주소 체계에서 설명한 클래스(Class) 기반의 IP 주소 체계를 클래스풀(Classful)이라고 부른다.

현재는 서브넷 마스크를 자주 이용하지만 초창기엔 서브넷 마스크 없이 네트워크를 구축했다. 서브넷 마스크가 없을 때 주로 사용하는 방식이 클래스풀 방식이다. 서브넷 마스크를 지정하고 그에 맞게 사용을 하기 때문에 정보를 주고 받을 때 서브넷 마스크 정보 없이 통신을 했다. 하지만 서브넷 마스크 도입 후 클래스 리스 방식을 주로 사용하는데 네트워크 정보를 주고 받을 시 서브넷 마스크까지 전달하는 방법을 뜻한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%205.png)

> 기본 서브넷 마스크
> 

**클래스 풀 (Classful)**

- 라우팅 정보 전송시 서브넷 마스크 전달을 하지 않는다.
- 대표적인 프로토콜 RIRv1, IGRP
- 클래스풀 라우팅프로토콜에서 서브넷 마스크를 사용할때는 제약사항들이 있다.

**클래스 리스 (Classless)**

- 라우팅 정보전송시 서브넷 마스크 정보도 포함
- 대표적인 프로토콜 RIRv2, EIGRP, OSPF, BGP 프로토콜이 여기 포함된다.

---

### 서브네팅

원래 부여된 클래스의 기준을 무시하고 새로운 네트워크-호스트 구분 기준을 사용자가 정해 원래 클래스풀 단위의 네트워크보다 더 쪼개 사용하는 것을 서브네팅(Subnettiong)이라고 한다.

부여된 주소를 다시 잘라 사용해 서브네팅이라고 부르는데 현대 클래스리스 네트워크의 가장 큰 특징이다. 옥텟 단위보다 더 잘게 네트워크를 쪼개 2진수의 1비트 단위로 네트워크를 분할한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%206.png)

> 다양한 서브네팅. 옥텟 단위가 아닌 2진수 자리 단위로 서브네팅한다.
> 

---

### 공인 IP와 사설 IP

인터넷에 접속하려면 IP주소가 있어야 하고 이 IP는 **전 세계에서 유일해야 하는 식별자**이다. 이런 IP주소를 **공인 IP** 라고 한다. 하지만 인터넷에 연결하지 않고 개인적으로 네트워크를 구성한다면 **공인 IP주소를 할당받지 않고도** 네트워크를 구축할 수 있는데 이때 사용하는 IP 주소를 **사설 IP주소**라고 한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%207.png)

> 클래스별 사설 IP 주소 (RFC 1918: [https://tools.ieft.org/html/rfc](https://tools.ieft.org/html/rfc)1918)
> 

---

## 3.4 TCP와 UDP

앞서 설명한 2계층과 3계층은 목적지를 정확히 찾아가기 위한 주소 제공이였지만 4계층에서 동작하는 프로토콜은 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 한다.

**쉽게 말해 데이터의 전달을 담당한다.**

### TCP(Transmission Control Protocol)

TCP는 **인터넷상에서 데이터를 메세지의 형태로 보내기 위해 IP와 함께 사용하는 프로토콜**이다.

 일반적으로 TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리하게 된다. TCP는 연결형 서비스를 지원하는 프로토콜로 인터넷 환경에서 기본으로 사용한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%208.png)

> TCP 가상회선 패킷 교환 방식
> 

**[TCP 특징]**

- 연결형 서비스로 가상 회선 방식을 제공한다.
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식

TCP는 **연속성보다 신뢰성있는 프로토콜로 전송**이 중요할 때에 사용하는 프로토콜로 예를 들면 파일 전송과 같은 경우에 사용된다.

[**TCP 서버의 특징]**

- 서버소켓은 연결만을 담당한다.
- 연결과정에서 반환된 클라이언트 솤넷은 송수신에 사용된다형 서비스로 가상 회선 방식을 제공한다.
- 서버와 클라이언트는 1대1로 연결된다
- 스트림 전송으로 전송 데이터의 크기가 무제한이다.
- 패킷에 대한 응답을 해야하기 때문에(시간 지연, CPU 소모) 성능이 낮다.
- Streaming 서비스에 불리하다. (손실된 경우 재전송 요청을 하므로)

---

### UDP(User Datagram Protocol)

UDP는 **데이터를 데이터그램 단위로 처리하는 프로토콜**이다.

 여기서 데이터그램이란 독립적인 관계를 지니는 패킷이라는 뜻으로, TCP와 달리 UDP는 비 연결형 프로토콜이다. 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 되는데 이렇게 서로 다른 경로로 독립적으로 처리하게 되고 이러한 프로토콜을 UDP라 한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%209.png)

**[UDP 특징]**

- 비 연결형 서비스로 데이터그램 방식을 제공한다.
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다.
- TCP보다 속도가 빠르다.

UDP는 비연결형 서비스이기 때문에 연결을 설정하고 해제하는 과정이 존재하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만, 신뢰성있는 데이터의 전송을 보장하지는 못한다. **신뢰성보다는 연속성이 중요한 서비스** 예를 들면 실시간 서비스(Streaming)에 자주 사용된다.

**[UDP 서버의 특징]**

- UDP에는 연결 자체가 없어서 (connect 함수 불필요) 서버 소켓과 클라이언트 소켓의 구분이 없다.
- 소켓 대신 IP를 기반으로 데이터를 전송한다.
- 서버와 클라이언트는 1대1, 1대N, N대M 등으로 연결될 수 있다.
- 데이터그램(메세지) 단위로 전송되며 그 크기는 65535바이트로, 크기가 초과하면 잘라서 보낸다.
- 흐름제어(flow control)가 없어서 패킷이 제대로 전송되었는지, 오류가 없는지 확인할 수 없다.
- 파일 전송과 같은 신뢰성이 필요한 서비스보다 성능이 중요시되는 경우에 사용된다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2010.png)

> TCP와 UDP의 비교
> 

---

## 3.5 ARP

ARP는 Address Resolution Protocol의 약자로 **IP 주소를 MAC 주소와 매칭 시키기 위한 프로토콜**이다.  

 로컬 네트워크에서 단말과 단말 간 통신을 하기 위해서는 IP 주소와 함께 MAC 주소를 이용하게 되는데 IP주소를 MAC Adress와 매칭하여 목적지 IP에 단말이 소유한 MAC 주소를 향해 제대로 찾아가기 위함이다.

<aside>
💡 단말간 통신에서 양쪽 단말은 IP를 이용하여 목적지를 지정하지만 실제 데이터 이동을 위해 **MAC 주소**를 함께 사용한다. 이를 위해 필요한 것이 **Address Resolution Protocol(ARP)**이며 **IP 주소와 MAC 주소를 일대일 매칭**하여 LAN(Layer 2)에서 목적지를 제대로 찾아갈 수 있도록 돕는다.

</aside>

IP 주소와 MAC 주소를 일대일 대응하여 테이블로 정리하고 목적지 IP에 맞는 목적지 MAC 주소로 전달한다. 이것을 ARP Table 이라고 부른다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2011.png)

> PC0의 ARP Table
> 

---

### ARP 동작

ARP 패킷은 여러 가지 필드 중 ARP 데이터에 사용되는 송신자 하드웨어 MAC 주소, 송신자 IP 프로토콜 주소, 대상자 MAC 주소, 대상자 IP 프로토콜 주소 4개의 필드가 중요하게 사용된다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2012.png)

> ARP 패킷
> 

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2013.png)

1. 목적지로 보내기 위한 MAC 주소를 모르면 패킷을 만들 수 없다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2014.png)

1. 목적지로 보내기 위한 IP 주소와 MAC 주소를 확인하기 위해 ARP 요청을 사용한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2015.png)

1. ARP 요청에 있는 목적지 IP 주소가 자신인 경우, 출발지로 ARP 응답을  전송한다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2016.png)

1. ARP 캐시 테이블에 IP 주소에 대한 MAC 주솟값을 패킷을 생성해 전송한다.

### GARP(Gratuitous ARP)

ARP는 상대방의 MAC 주소를 알아내기 위해 사용되는 반면, GARP는 자신의 IP와 MAC 주소를 알릴 목적으로 사용된다.

GARP를 사용해 동일 네트워크에 자신의 IP 주소와 MAC 주소를 알려주는 이유는 다음과 같다.

- IP 주소 충돌 감지
- 상대방(동일 서브넷 상의 다른)의 ARP 테이블 갱신
- HA(고가용성) 용도의 클러스터링, VRRP, HSRP

### RARP

RARP는 Reverse ARP로 말 그대로 반대로 동작하는 ARP인데 GARP처럼 ARP 프로토콜 구조는 같지만 필드에 들어가는 내용이 다르고 원래 목적과 반대로 사용된다.

![Untitled](Ch_3%20%E1%84%82%E1%85%A6%E1%84%90%E1%85%B3%E1%84%8B%20fc3cd/Untitled%2017.png)

> APR와 RARP의 차이점
> 

RAPR 는 IP 주소가 정해져 있지 않은 단말이 IP 할당을 요청할 때 사용된다.

<aside>
📌 ARP는 내가 통신해야 할 상대방의 MAC 주소를 모를 때 상대방의 IP주소로 MAC 주소를 물어볼 목적으로 만들어진 프로토콜이다. RARP는 반대로 나 자신의 MAC 주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는 서버에 어떤 IP 주소를 써야 하는지 물어볼 때 사용된다.

</aside>

RARP는 과거에 네트워크 호스트의 주소 할당에 사용되었지만 제한된 기능으로 인해 BOOTP와 DHCP로 대체되어 사용되지 않는다.

---

## 3.6 서브넷과 게이트웨이

**로컬 네트워크**

로컬 네트워크에서는 ARP 브로드캐스트를 이용해 도착지 MAC 주소를 학습할 수 있고 이 MAC 주소를 이용해 직접 통신할 수 있다.

**원격 네트워크**

반면 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질 때문에 네트워크 장비의 도움이 필요하다.

이 장비를 **게이트웨이**라고 하고 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 **기본 게이트웨이(Default Gateway)**다. 기본 게이트웨이는 3계층 장비가 수행하고 여러 네트워크와 연결되면서 적절한 경로를 지정해주는 역할을 한다.

---

출발지와 목적지 네트워크가 동일한 LAN내에서 통신하는 것인지, 서로 다른 네트워크 간의 통신인 확인하기 위해서 출발지에서는 먼저 목적지가 자신이 속한 네트워크의 범위인지 확인해야 합니다.

이때 사용되는 것이 서브넷 마스크입니다.

- 동일 네트워크 간의 통신과 다른 네트워크 간의 통신은 방식과 장비의 차이가 있다.
- 로컬 통신(동일 네트워크 간 통신)은 ARP 요청으로 목적지를 찾아 통신할 수 있다.
- 원격지 통신의 경우, 라우터를 넘어가지 못하는 브로드캐스트를 위한 외부와 통신 가능한 장비의 도움이 필요하다.
- **출발지와 목적지가 같은 네트워크인지를 확인하기 위해 사용되는 것이 서브넷 마스크이다.**

### 프록시 ARP

프록시 ARP(Proxy ARP)는 ARP를 대행해주는 기능이다.

원격지 통신은 기본 게이트웨이를 찾아 ARP 요청을 보내고 패킷을 기본 게이트웨이쪽으로 보내야만 통신이 가능하다.

하지만 기본 게이트웨이에 프록시 ARP가 활성화된 경우, 원격지 통신이더라도 로**컬에 ARP 브로드캐스트**를 보내 통신할 수 있다.  

- 프록시 ARP가 활성화된 기본 게이트웨이(라우터)는 ARP 브로드캐스트가 들어오면 자신이 대행 ARP 응답을 해준다.
- 이 경우, 패킷이 기본 게이트웨이 쪽으로 보내지므로 원격지 경로를 전달될 수 있다.

프록시 ARP 기능은 라우터에 기본으로 활성화되어 있어 사용자 몰래 동작하는 경우가 많다.

하지만 네트워크 설정 오류가 있거나 꼭 입력해야 할 설정이 되어 있지 않아도 동작하는 경우가 있어 장애가 발생했을 때 쉽게 해결할 수 없게 만드는 **장애 요소**가 되기도 한다.

### **2계층 통신 vs 3계층 통신**

2계층 통신, 3계층 통신은 정확한 표현은 아니지만 실무에서 많이 쓰이는 표현이다.

정확한 표현으로는 로컬 네트워크 통신, 원격지 네트워크 통신이다.

**로컬 네트워크 통신**

단말 간의 통신은 애플리케이션 계층부터 시작해 캡슐화, 디캡슐화를 거쳐 통신하는데 **로컬 네트워크에서 직접 통신할 경우, 3계층의 네트워크 장비 도움 없이 통신이 가능하다.**

즉, 단말 간 연결해주는 네트워크 장비에서 2계층까지만 정보를 확인해 통신하고 ARP 요청을 보낼 때 직접 브로드캐스트를 이용하므로 2계층 통신(L2 통신)이라 부른다.

**원격지 네트워크 통신**

원격지 네트워크와 통신해야 할 경우, 라우터와 같은 3계층 장비의 도움이 없으면 통신할 수 없다.

해당 패킷을 전송하는 네트워크 장비에서 3계층 정보까지 확인해야 하며 이것을 3계층 통신(L3 통신)이라 부른다.

![https://chaelin1211.github.io/img/posts/inPost/l2%20l3%20communication.png](https://chaelin1211.github.io/img/posts/inPost/l2%20l3%20communication.png)

> 중간에 어느 계층까지 확인하는지에 따라 2계층 통신과 3계층 통신으로 나뉜다.
> 

외부 네트워크와 통신이 필요할 때는 단말이 자신이 직접 보낼 수 없는 위치에 목적지가 있다고 판단하고 **ARP 요청을 기본 게이트웨이의 IP 주소로** 요청한다.

게이트웨이에서 ARP 응답을 답은 단말은 도착지 MAC 주소에 응답받은 기본 게이트웨이의 MAC 주소를 넣고 통신을 시작한다.

- 로컬 통신은 도착지 MAC 주소와 도착지 IP 주소가 같다.
- 원격지 통신은 도착지 MAC 주소와 도착지 IP 주소가 다르다.
    - 도착지 IP 주소는 통신의 실제 도착지이고 도착지 MAC 주소는 기본 게이트웨이의 MAC 주소가 사용된다.